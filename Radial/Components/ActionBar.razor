@using Radial.Enums
@using Radial.Services
@using Radial.Services.Client
@using Radial.Utilities
@inject IInputDispatcher InputDispatcher
@inject IClientConnection ClientConnection
@inject IMessagePublisher MessagePublisher
@inject IModalService ModalService
@inject IUiNoticiations UiNotifications 

<div class="action-bar-frame" tabindex="0" @onkeydown="OnKeyDown">
    <div class="action-bar-top-row">
        <div></div>
        <div>
            <span class="text-info">Target:</span>
            <span>@(CharacterInfo?.Target?.Name) [@(CharacterInfo?.Target?.EnergyPercentFormatted)]</span>
        </div>
        <div>
            <span class="text-info">Guard:</span>
            <span>@(CharacterInfo?.GuardAmount)</span>
        </div>
    </div>
    @if (CharacterInfo?.EnergyCurrent < 1)
    {
        <button id="respawnButton" class="btn btn-danger" @onclick="Respawn">Respawn</button>
    }
    else
    {
        @if (CharacterInfo?.State == CharacterState.InCombat)
        {
            <div class="text-center">
                <button id="escapeButton" class="btn btn-danger" style="transform: translate(-50%, 50%)" @onclick="Escape">Escape</button>
            </div>
        }
        else
        {
            <div class="button-control-frame">
                <button class="btn btn-primary dpad-button top-button" title="Move North" @onclick="() => Move(MovementDirection.North)">N</button>
                <button class="btn btn-primary dpad-button right-button" title="Move East" @onclick="() => Move(MovementDirection.East)">E</button>
                <button class="btn btn-primary dpad-button bottom-button" title="Move South" @onclick="  () => Move(MovementDirection.South)">S</button>
                <button class="btn btn-primary dpad-button left-button" title="Move West" @onclick=" () => Move(MovementDirection.West)">W</button>
            </div>
        }

        <div class="button-control-frame">
            @if (CharacterInfo?.State == CharacterState.InCombat)
            {
                <div class="action-bonus-ring"
                     style="opacity: @CharacterInfo?.ActionBonus;
                        transform: translate(-50%, -50%) scale(@($"{CharacterInfo?.ActionBonus},{CharacterInfo?.ActionBonus}"));
                        border-color: @(CharacterInfo?.ActionBonus > .9 ? "limegreen" : "unset")">

                </div>
            }
            else
            {
                <div></div>
            }

            <div>
                <button class="btn btn-primary dpad-button top-button" title="Attack" @onclick="Attack">
                    <img src="/media/svg/sword.svg" />
                </button>
                <button class="btn @GetGuardStyle() dpad-button right-button" title="Guard" @onclick="Guard">
                    <img src="/media/svg/shield.svg" />
                </button>
                <button class="btn btn-primary dpad-button bottom-button" title="Heal" @onclick="Heal">
                    <img src="/media/svg/heal.svg" />
                </button>
                <button class="btn btn-primary dpad-button left-button" title="Blast" @onclick="Blast">
                    <img src="/media/svg/blast.svg" />
                </button>
            </div>
        </div>

        <div class="target-button-frame">
            <button class="btn btn-sm btn-success target-button" title="Cycle Friendly Target" @onclick="CycleFriendlyTarget">
                <span class="oi oi-target"></span>
            </button>
            <button class="btn btn-sm btn-danger target-button" title="Cycle Enemy Target" @onclick="CycleEnemyTarget">
                <span class="oi oi-target"></span>
            </button>
            <button class="btn btn-sm btn-warning target-button" title="Powers" @onclick="OpenPowersMenu">
                <span class="oi oi-bolt"></span>
            </button>
        </div>
    }
</div>

@code {
    private PlayerCharacter CharacterInfo { get; set; }

    protected override Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            CharacterInfo = ClientConnection.Character;
            MessagePublisher.DataStateChanged += (sender, args) =>
            {
                InvokeAsync(StateHasChanged);
            };
        }
        return base.OnAfterRenderAsync(firstRender);
    }

    private void Attack()
    {
        InputDispatcher.Attack(ClientConnection);
    }

    private void Blast()
    {
        InputDispatcher.Blast(ClientConnection);
    }

    private void Guard()
    {
        InputDispatcher.Guard(ClientConnection);
    }

    private void CycleEnemyTarget()
    {
        var location = ClientConnection.Location;

        var currentIndex = location.Characters.IndexOf(CharacterInfo.Target);
        if (currentIndex == -1)
        {
            CharacterInfo.Target = location.Characters.FirstOrDefault(x => x.Type == CharacterType.NPC);
        }
        else
        {
            CharacterInfo.Target = location.Characters
                .Skip(currentIndex + 1)
                .FirstOrDefault(x => x.Type == CharacterType.NPC);
        }

        ClientConnection.InvokeMessageReceived(GenericMessage.StateChanged);
    }

    private void CycleFriendlyTarget()
    {
        var location = ClientConnection.Location;

        var currentIndex = location.Characters.IndexOf(CharacterInfo.Target);
        if (currentIndex == -1)
        {
            CharacterInfo.Target = location.Characters.FirstOrDefault(x => x.Type == CharacterType.Player);
        }
        else
        {
            CharacterInfo.Target = location.Characters
                .Skip(currentIndex + 1)
                .FirstOrDefault(x => x.Type == CharacterType.Player);
        }

        ClientConnection.InvokeMessageReceived(GenericMessage.StateChanged);
    }

    private void Escape()
    {
        InputDispatcher.EscapeCombat(ClientConnection);
    }

    private string GetGuardStyle()
    {
        if (CharacterInfo?.IsGuarding == true)
        {
            return "btn-success";
        }
        return "btn-primary";
    }

    private void Heal()
    {
        InputDispatcher.Heal(ClientConnection);
    }

    private void Move(MovementDirection direction)
    {
        if (DateTimeOffset.Now - CharacterInfo.LastMoveTime < TimeSpan.FromMilliseconds(100))
        {
            return;
        }

        if (CharacterInfo.State != CharacterState.Normal)
        {
            return;
        }

        CharacterInfo.LastMoveTime = DateTimeOffset.Now;

        InputDispatcher.MoveCharacter(ClientConnection, direction);
    }

    private void OnKeyDown(KeyboardEventArgs args)
    {
        switch (args.Key)
        {
            case "A":
            case "a":
                Move(MovementDirection.West);
                break;
            case "W":
            case "w":
                Move(MovementDirection.North);
                break;
            case "D":
            case "d":
                Move(MovementDirection.East);
                break;
            case "S":
            case "s":
                Move(MovementDirection.South);
                break;
            case "ArrowLeft":
            case "Left":
                Blast();
                break;
            case "ArrowUp":
            case "Up":
                Attack();
                break;
            case "ArrowRight":
            case "Right":
                Guard();
                break;
            case "ArrowDown":
            case "Down":
                Heal();
                break;
        }
    }
    private void OpenPowersMenu()
    {
        UiNotifications.InvokePowersMenuOpenedEvent();
    }
    private void Respawn()
    {
        InputDispatcher.Respawn(ClientConnection);
    }
}